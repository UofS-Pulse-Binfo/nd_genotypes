<?php
namespace Tests\api;

use StatonLab\TripalTestSuite\DBTransaction;
use StatonLab\TripalTestSuite\TripalTestCase;
use  Tests\DatabaseSeeders\GeneticMarkerSeeder;

/**
 * Tests the following API functions:
 *   - nd_genotypes_get_IUPAC_code()
 *   - nd_genotypes_expand_IUPAC_code()
 *   - nd_genotype_get_consensus_call()
 *   - nd_genotypes_complement_calls()
 *   - nd_genotypes_get_alleles_for_variant()
 */
class allelesTest extends TripalTestCase {
  // Uncomment to auto start and rollback db transactions per test method.
  use DBTransaction;

  /**
   * Tests nd_genotypes_get_IUPAC_code().
   *
   * @group alleles
   */
  public function testGetIUPAC() {

    $test_combinations = [
      'CG' => 'S',
      'AT' => 'W',
      'CGT' => 'B',
      'GTA' => 'D',
      'C' => 'C',
      'CGGCCGCCG' => 'S',
      'TTTTTTTTT' => 'T',
    ];
    foreach ($test_combinations as $alleles => $code) {
      $result = nd_genotypes_get_IUPAC_code($alleles);
      $this->assertEquals($code, $result);
    }

    // We should also test one that should not work.
    $result = nd_genotypes_get_IUPAC_code('FRED');
    $this->assertFalse($result);
  }

  /**
   * Tests nd_genotypes_expand_IUPAC_code().
   *
   * @group alleles
   */
  public function testExpandIUPAC() {

    $test_combintations = [
      'S' => 'CG',
      'W' => 'AT',
      'B' => 'CGT',
      'C' => 'C',
      'CTC' => 'CT',
      'TTTTTTTT' => 'T',
      'SB' => 'CGT',
    ];

    foreach ($test_combintations as $codes => $alleles) {
      $result = nd_genotypes_expand_IUPAC_code($codes);
      $this->assertEquals($alleles, $result);
    }
  }

  /**
   * Tests nd_genotype_get_consensus_call().
   *
   * @group alleles
   */
  public function testGetConsensusCall() {

    $test_combinations = [
      'A' => ['A','A','A','A','A','A','T'],
      'T' => ['T'],
      'C' => ['A','C','A','C','A','C','C'],
      NULL => [],
    ];
    foreach ($test_combinations as $consensus => $alleles) {
      $result = nd_genotype_get_consensus_call($alleles);
      $this->assertEquals($consensus, $result);
    }
  }

  /**
   * Tests nd_genotypes_complement_calls().
   *
   * @group alleles
   */
  public function testComplementCalls() {

    $calls = 'T';
    $expect = 'A';
    $result = nd_genotypes_complement_calls($calls);
    $this->assertEquals($expect, $result,
      "Unable to complement single allele string.");

    $calls = ['T'];
    $expect = ['A'];
    $result = nd_genotypes_complement_calls($calls);
    $this->assertEquals($expect, array_values($result),
      "Unable to complement single allele array.");

    $calls = ['T', 'T', 'C', 'A'];
    $expect = ['A', 'G', 'T'];
    $result = nd_genotypes_complement_calls($calls);
    $this->assertEquals($expect, array_values($result),
      "Unable to complement multi-allele array.");

    // Expect it to not be able to complement.
    $calls = 'FRED';
    $expect = FALSE;
    $result = nd_genotypes_complement_calls($calls);
    $this->assertEquals($expect, array_values($result),
      "Did not fail to complement when it should have.");
  }

  /**
   * Tests nd_genotypes_get_alleles_for_variant().
   *
   * @group alleles
   * @group workingon
   *
   * @todo
   */
  public function testGetAlleles4Variant() {

    // Try it before the partition exists.
    $alleles_returned = nd_genotypes_get_alleles_for_variant(
      1, uniqid());
    $this->assertFalse($alleles_returned,
      "This should be false since the tables do not exist yet.");

    // Create a marker/variant dataset.
    $seeder = new GeneticMarkerSeeder();
    $data = $seeder->up();
    $genotype_data = $seeder->addGenotypes(10);
    $partition = strtolower($data['organism']['genus']);
    $mview = $seeder->syncMviews($partition);
    $srcfeature_name = $data['chromosome']['record']->name;

    // Compile a list of the alleles that were generated by the seeder.
    $allele_set = [];
    foreach($genotype_data as $g) {
      if (!isset($allele_set[ $g['allele'] ])) {
        $allele_set[ $g['allele'] ] = 0;
      }
      $allele_set[ $g['allele'] ]++;
    }

    // Check alleles for the given variant.
    $alleles_returned = nd_genotypes_get_alleles_for_variant(
      $data['variant']['variant_id'], $partition);

    foreach($alleles_returned['alleles'] as $key => $returned) {
      $this->assertEquals($allele_set[$key], $returned['num_germplasm'],
        "The number of times this allele showed up was not what we expected.");
    }

    // Now check that the numbers for the only marker are the same.
    $alleles_returned = nd_genotypes_get_alleles_for_variant(
      $data['marker']['marker_id'], $partition, ['single marker' => TRUE]);

    foreach($alleles_returned['alleles'] as $key => $returned) {
      $this->assertEquals($allele_set[$key], $returned['num_germplasm'],
        "The number of times this allele showed up was not what we expected.");
    }

  }

  /**
   * Tests nd_genotypes_set_default_colours().
   *
   * @group alleles
   */
  public function testSetDefaultColours() {
    nd_genotypes_set_default_colours();

    $result = variable_get('nd_genotypes_SNP_colours', FALSE);
    $this->assertNotFalse($result,
      "Unable to retrieve nd_genotypes_SNP_colours.");
    $unserialized = unserialize($result);
    $this->assertIsArray($unserialized,
      "Unable to unserialize nd_genotypes_SNP_colours.");

    $result = variable_get('nd_genotypes_allele_colours', FALSE);
    $this->assertNotFalse($result,
      "Unable to retrieve nd_genotypes_allele_colours.");
    $unserialized = unserialize($result);
    $this->assertIsArray($unserialized,
      "Unable to unserialize nd_genotypes_allele_colours.");
  }
}
