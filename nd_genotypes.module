<?php

// API
require_once 'api/nd_genotypes.api.inc';

// Includes
require_once 'includes/nd_genotypes.admin.inc';
require_once 'includes/nd_genotypes.form_elements.inc';

// Mviews
require_once 'includes/mviews/nd_genotype_experiment.inc';
require_once 'includes/mviews/nd_genotype_polymorphism.inc';
require_once 'includes/mviews/nd_genotype_experiment_summary.inc';

/**
 * Implements hook_views_api()
 *
 * Purpose: Essentially this hook tells drupal that there is views support for
 *  for this module which then includes kp_genotypes.views.inc where all the
 *  views integration code is
 *
 * @return
 *   An array with fields important for views integration
 *
 */
function nd_genotypes_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'nd_genotypes') . '/includes/views',
  );
}

/**
 * Register any menu items for this module
 */
function nd_genotypes_menu () {
	$items = array();

  $items['form/test'] = array(
    'title' => 'Natural Diversity Genotypes',
    'description' => 'Provides an interface for genotypes and the experiments that generate them.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nd_genotypes_test_form'),
    'access arguments' => array('access content'),
  );

	$items['admin/tripal/extension/nd_genotypes'] = array(
    'title' => 'Natural Diversity Genotypes',
    'description' => 'Provides an interface for genotypes and the experiments that generate them.',
    'access arguments' => array('administer tripal'),
    'page callback' => 'nd_genotypes_admin_launchpad'
  );

  $items['admin/tripal/extension/nd_genotypes/configuration'] = array(
    'title' => 'Settings',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nd_genotypes_configuration_form'),
    'access arguments' => array('administer tripal'),
  );

   $items['admin/tripal/extension/nd_genotypes/mviews'] = array(
    'title' => 'Materialized Views',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nd_genotypes_mviews_update_form'),
    'access arguments' => array('administer tripal'),
  );

	return $items;
}

/**
 * Register any theme functions/templates for this module
 */
function nd_genotypes_theme() {
  return array();
  //return nd_genotypes_form_element_theme();
}

/**
 * Get the parent sequence and then mark-up any variants including the current one using
 * a combination of IUPAC codes and [A/T] notation.
 *
 * @param $feature_id
 *   The feature of interest (can be either the base contig, variant or marker)
 * @param $feature_category
 *   Either 'variant', 'marker' or 'sequence'. This is optional and will be determined
 *   if not supplied.
 * @param $info
 *   An array of information you would like to supply rather than allow this function to
 *   determine on it's own. All these keys are optional but if you already have the
 *   information it is much faster to provide it in this manner.
 *   Approved keys include:
 *    - * sequence: the full sequence you would like to display. For example, the entire
 *        sequence of the contig a variant is located on or a subset of the sequence of a
 *        chromosome.
 *    - srcfeature_id: the parent feature_id
 *    - feature_position: the fmin of the SNP/marker, FALSE if sequence feature
 *   Sometimes the parent sequence is too long to be displayed in full. In these cases,
 *   you might want to specify the region to be shown. This can be done by providing the
 *   sequence using the above option but in order to ensure you only pull genotypes for that
 *   region or to allow this function to handle getting the substring, you should specify
 *   either the flanking sequence length or the start and end coordinates using the
 *   following options:
 *    - maximum_sequence_length: the maximum length of sequence you would like returned. Default = 600
 *    - flanking_sequence_length: the number of bases on either side of the feature indicated
 *      by the $feature_id
 *
 * @return
 *  The parent sequence and then mark-up any variants including the current one using
 *  a combination of IUPAC codes and [A/T] notation.
 */
function nd_genotypes_markup_variant_sequence($feature_id, $feature_category = FALSE, $info) {
  $sequence = '';
  $line_length = 50;
  $self_fmin = (isset($info['feature_position'])) ? $info['feature_position'] : FALSE;
  $info['maximum_sequence_length'] = (isset($info['maximum_sequence_length'])) ? $info['maximum_sequence_length'] : 1000;
  $variant_types = array('SNP', 'MNP','indel');

  // Store return array
  $marked_up_seq_details = array();

  // Get all variants for contig
  if ($feature_category == 'sequence') {
    $info['srcfeature_id'] = $feature_id;
  }
  if (isset($info['srcfeature_id'])) {
    $options = array();
    $options['include_fk'] = array('feature_id' => array('type_id' => TRUE));
    $options['order_by'] = array('fmin' => 'ASC');
    $options['return_array'] = TRUE;
    // @TODO: only grab the featurelocs in the shortened sequence range.
    // Currently chado_generate_var() doesn't support > < operators.
    $featurelocs = chado_generate_var('featureloc', array('srcfeature_id' => $info['srcfeature_id']), $options);
    $featurelocs = chado_expand_var($featurelocs, 'table','feature_genotype', array('return_array' => TRUE));
    $loc_key = 'feature_id';
  }

  // Foreach, if its a variant keep it's position and nid
  // for use in creating links below
  $all_variants = array();
  foreach ($featurelocs as $loc) {
    // Check it's a variant
    if (in_array($loc->{$loc_key}->type_id->name, $variant_types)) {
      if (isset($loc->feature_id->nid)) {
        $all_variants[$loc->fmin] = 'node/'.$loc->feature_id->nid;
      }

      if ($loc->feature_id->feature_id == $feature_id) {
        $self_fmin = $loc->fmin;
      }
    }
    else {
      if ($loc->feature_id->feature_id == $feature_id) {
        $self_fmin = $loc->fmin;
      }
    }
  }

  // Determine if we are dealing with a really long base sequence, in which case we need
  // to substring what is returned to make it more managable
  // Needs to be done here b/c before this point we don't have the location of the current feature
  if (strlen($info['sequence']) > $info['maximum_sequence_length']) {
    if ($self_fmin) {
      $half_point = $info['maximum_sequence_length'] / 2;
      $start = (($self_fmin - $half_point) >= 0) ? $self_fmin - $half_point : 0;
      $sequence = substr($info['sequence'], $start, $info['maximum_sequence_length']);
    }
    else {
      $start = 0;
      $sequence = substr($info['sequence'], 0, $info['maximum_sequence_length']);
    }
    $end = $start + $info['maximum_sequence_length'];
  }
  else {
    $start = 0;
    $end = $start + strlen($info['sequence']);
    $sequence = $info['sequence'];
  }
  $marked_up_seq_details['shortened_sequence'] = $sequence;
  $sequence = str_split($sequence);

  // Foreach, if it's a marker then mark it up
  // keep all the alleles so that if there is more than one marker per variant
  // both get taken into account
  $all_alleles = array();
  foreach ($featurelocs as $loc) {
    // Use the position to take into account that the sequence might be substringed
    $position = $loc->fmin - $start;
    $original_position = $loc->fmin;

    // Ensure that the current location is still on the substring
    // Check it's a variant
    if ($loc->{$loc_key}->type_id->name == 'marker' AND $original_position <= $end AND $original_position >= $start) {

      // Get the genotype
      if (isset($loc->feature_id->feature_genotype->feature_id)) {
        if (is_object($loc->feature_id->feature_genotype->feature_id)) {
          $loc->feature_id->feature_genotype->feature_id = array($loc->feature_id->feature_genotype->feature_id);
        }
        foreach ($loc->feature_id->feature_genotype->feature_id as $a) {
          foreach(str_split($a->genotype_id->description) as $allele) {
            $all_alleles[$loc->feature_id->feature_id][$allele] = $allele;
          }
        }

        // Get the IUPAC Code
        $genotype = implode('', $all_alleles[$loc->feature_id->feature_id]);
        $code = nd_genotypes_get_IUPAC_code($genotype);
        $genotype_type = 'IUPAC';

        // If this SNP is for the feature passed in
        // then don't use the IUPAC code
        if ($self_fmin == $original_position) {
          $code = '[' . implode('/', $all_alleles[$loc->feature_id->feature_id]) . ']';
          $genotype_type = 'expanded';
        }
      }
      else {
        if ($self_fmin == $original_position) {
          $code = '[' . $sequence[$position] . ']';
          $genotype_type = 'expanded';
        }
        else {
          $code = $sequence[$position];
          $genotype_type = 'IUPAC';
        }
        tripal_report_error('nd_genotypes',TRIPAL_WARNING, 'There are no genotypes set for %feature_id to determine how to markup the sequence',array('%feature_id' => $feature_id));
      }

      // Create a link if this feature is sync'd
      $code = (!empty($code)) ? $code : '';
      $display = $code;
      if (isset($all_variants[$original_position])) {
        $display = l($code, $all_variants[$original_position]);
      }

      // Change the nucleotide
      if((($loc->fmax - $loc->fmin) == 1) AND $code) {
        $sequence[$position] =
          "<span class='variant variant-$genotype_type'>"
            . $display
        . "</span>";
      }
    }
  }
  $marked_up_seq_details['start'] = $start;
  $marked_up_seq_details['end'] = $end;
  $marked_up_seq_details['marked_up_sequence'] = implode('',$sequence);

  return $marked_up_seq_details;
}

function nd_genotypes_get_IUPAC_code($alleles) {
  $IUPAC = array(

        'A' => 'A',
        'T' => 'T',
        'C' => 'C',
        'G' => 'G',

        'AG' => 'R',
        'GA' => 'R',

        'CT' => 'Y',
        'TC' => 'Y',

        'GC' => 'S',
        'CG' => 'S',

        'AT' => 'W',
        'TA' => 'W',

        'GT' => 'K',
        'TG' => 'K',

        'AC' => 'M',
        'CA' => 'M',

        'CGT' => 'B',
        'CTG' => 'B',
        'GCT' => 'B',
        'GTC' => 'B',
        'TGC' => 'B',
        'TCG' => 'B',

        'AGT' => 'D',
        'ATG' => 'D',
        'GAT' => 'D',
        'GTA' => 'D',
        'TGA' => 'D',
        'TAG' => 'D',

        'ACT' => 'H',
        'ATC' => 'H',
        'CAT' => 'H',
        'CTA' => 'H',
        'TCA' => 'H',
        'TAC' => 'H',

        'ACG' => 'V',
        'AGC' => 'V',
        'CAG' => 'V',
        'CGA' => 'V',
        'GAC' => 'V',
        'GCA' => 'V',
      );

  if (isset($IUPAC[$alleles])) {
    return $IUPAC[$alleles];
  }
  else {
    return FALSE;
  }
}
