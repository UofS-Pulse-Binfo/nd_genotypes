<?php
/**
 * @file
 * Contains general functionality for this module.
 */

require_once('api/nd_genotypes.api.inc');

require_once('includes/nd_genotypes.mview.inc');
require_once('includes/nd_genotypes.form_elements.inc');

/**
 * Implements hook_menu().
 */
function nd_genotypes_menu() {

  // Administration.
  $items['admin/tripal/extension/nd_genotypes'] = array(
    'title' => 'Natural Diversity Genotypes',
    'description' => 'Provides an interface for genotypes and the experiments that generate them.',
    'access arguments' => array('administer tripal'),
    'page callback' => 'nd_genotypes_admin_landing_page',
    'file' => 'includes/nd_genotypes.admin.inc'
  );

  $items['admin/tripal/extension/nd_genotypes/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nd_genotypes_admin_settings'),
    'access arguments' => array('administer tripal'),
    'weight' => 0,
    'file' => 'includes/nd_genotypes.admin.inc'
  );

  $items['admin/tripal/extension/nd_genotypes/sync'] = array(
    'title' => 'Sync',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nd_genotypes_admin_sync_mviews'),
    'access arguments' => array('administer tripal'),
    'weight' => 2,
    'file' => 'includes/nd_genotypes.admin.inc'
  );

  $items['admin/tripal/extension/nd_genotypes/help'] = array(
    'title' => 'Help',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'theme',
    'page arguments' => array('nd_genotypes__help'),
    'access arguments' => array('administer tripal'),
    'weight' => 4
  );

  // Add Marker x Germplasm Matrix links (1/organism synced)
  $sql = "
    SELECT *
    FROM [chado_organism] CO
      INNER JOIN {organism} O ON O.organism_id = CO.organism_id
    ORDER BY O.genus, O.species
  ";
  $orgs = chado_query($sql);
  foreach ($orgs as $organism) {
    $items['chado/genotype/' . $organism->genus] = array(
      'title' => $organism->genus . ' Genotypes',
      'description' => 'Marker by Germplasm Genotypes Search for ' . $organism->genus . ' species.',
      'page callback' => 'nd_genotype_matrix_page',
      'page arguments' => array($organism->genus),
      //'page callback' => 'drupal_get_form',
      //'page arguments' => array('nd_genotypes_matrix_filter_form', $organism->genus),
      'access arguments' => array('access content'),
      'type' => MENU_NORMAL_ITEM,
      'file' => 'includes/nd_genotypes.genotype_matrix.inc',
    );
  }

  return $items;
}

/**
 * Register any theme functions/templates for this module.
 * Implements hook_theme().
 */
function nd_genotypes_theme($existing, $type, $theme, $path) {
  $items = array();

  // Help Page
  // @todo: Update this page.
  $items['nd_genotypes__help'] = array(
    'template' => 'nd_genotypes--help',
    'path' => "$path/theme/templates",
  );

  // This is used for the "Germplasm" filter on the genotype matrix form.
  // It's a custom form element that lets you select multiple germplasm to be filtered on.
  $items['multiple_organism_stock'] = array(
    'render element' => 'element',
  );

  // This template executes the query as well as building the genotype matrix table.
  // The filter form is in nd_genotypes_matrix_filter_form().
  $items['nd_genotype_matrix'] = array(
    'template' => 'nd_genotypes.genotype_matrix',
    'path' => $path . '/theme/templates/',
  );

  // Features: Genotype pane
  $items['nd_genotypes_feature_genotypes'] = array(
    'variables' => array('node' => NULL),
    'template' => 'nd_genotypes_feature_genotypes',
    'path' => "$path/theme/templates",
  );

  // Features: Marked-up sequence pane
  $items['nd_genotypes_feature_sequence'] = array(
    'variables' => array('node' => NULL),
    'template' => 'nd_genotypes_feature_sequence',
    'path' => "$path/theme/templates",
  );

  return $items;
}

/**
 * Simple function to render the genotype matrix based on the template file.
 */
function nd_genotype_matrix_page($genus) {
  return theme('nd_genotype_matrix', array('genus' => $genus));
}

/**
 * Preprocess hook for nd_genotypes.genotype_matrix.tpl.php
 *
 * This function processes data from the URL into a more usable form. Each key in the
 * $vars array is made available as a variable in the template file.
 */
function nd_genotypes_preprocess_nd_genotype_matrix(&$vars) {

  // Add the CSS.
  drupal_add_css(drupal_get_path('module', 'nd_genotypes') . '/theme/css/nd_genotype_matrix.css');

  // Initialize some defaults.
  $vars['query'] = array('sql' => array(), 'args' => array());
  $vars['germplasm'] = array();
  $vars['defaults'] = array();

  // Save the query paramters.
  $vars['q'] = drupal_get_query_parameters();

  // Start to compile the header and template row.
  $vars['header'] = array(
    'variant_name' => array('data' => 'Variant Name', 'class' => array('variant_name')),
    'srcfeature_name' => array('data' => 'Backbone', 'class' => array('position','backbone')),
    'fmin' => array('data' => 'Start', 'class' => array('position', 'start')),
    'fmax' => array('data' => 'End', 'class' => array('position','end')),
  );
  $vars['template_row'] = array('variant_name' => '', 'srcfeature_name' => '', 'fmin' => '', 'fmax' => '');

  // Start the query.
  $vars['query']['sql'][] = 'SELECT';
  $vars['query']['sql'][] = '    variant_id,';
  $vars['query']['sql'][] = '    variant_name,';
  $vars['query']['sql'][] = '    srcfeature_name,';
  $vars['query']['sql'][] = '    fmin,';
  $vars['query']['sql'][] = '    fmax,';
  $vars['query']['sql'][] = '    germplasm_id,';
  $vars['query']['sql'][] = '    germplasm_name,';
  $vars['query']['sql'][] = '    d.nid,';
  $vars['query']['sql'][] = '    consensus_allele';
  $vars['query']['sql'][] = '  FROM {genotype_mview} gm';
  $vars['query']['sql'][] = '    LEFT JOIN [chado_feature] d ON d.feature_id=gm.variant_id';
  $vars['query']['sql'][] = '  WHERE';

  // --Germplasm.
  if (isset($vars['q']['germplasm'])) {
    foreach ($vars['q']['germplasm'] as $germ_id) {

      // retrieve more details.
      $s = chado_query('SELECT name, organism_id FROM {stock} WHERE stock_id=:id',
        array(':id' => $germ_id))->fetchObject();

      // Save details for later use.
      $vars['germplasm'][$germ_id] = array(
        'object' => $s,
        'name' => $s->name,
        'class' => strtolower(drupal_clean_css_identifier( $s->name )),
      );

      // Add to the header and template row.
      $vars['header'][$germ_id] = array('data' => $s->name, 'class' => array('germplasm', $vars['germplasm'][$germ_id]['class']));
      $vars['template_row'][$germ_id] = '';

      // Add to the query.
      $vars['query']['args'][':germplasm'][] = $germ_id;

      // Save as defaults for use in the form.
      $vars['defaults']['germ']['existing'][] = array(
        'stock_id' => $germ_id,
        'organism_id' => $s->organism_id,
        'stock_name' => $s->name,
      );
    }

    // Add germplasm to the query.
    $vars['query']['sql'][] = '    germplasm_id IN (:germplasm)';
  }

  // --Sequence Range.
  if (isset($vars['q']['seq_range'])) {
    if (isset($vars['q']['seq_range']['start']['backbone'])) {
      if (isset($vars['q']['seq_range']['start']['pos'])) {
        $vars['query']['sql'][] = '    AND ((srcfeature_name = :sbackbone AND fmin >= :sfmin::int) OR srcfeature_name > :sbackbone)';
        $vars['query']['args'][':sbackbone'] = $vars['q']['seq_range']['start']['backbone'];
        $vars['query']['args'][':sfmin'] = (int) $vars['q']['seq_range']['start']['pos'];

        $vars['defaults']['seq_range']['start']['backbone'] = $vars['q']['seq_range']['start']['backbone'];
        $vars['defaults']['seq_range']['start']['pos'] = $vars['q']['seq_range']['start']['pos'];
      }
      else {
        $vars['query']['sql'][] = '    AND (srcfeature_name >= :sbackbone)';
        $vars['query']['args'][':sbackbone'] = $vars['q']['seq_range']['start']['backbone'];

        $vars['defaults']['seq_range']['start']['backbone'] = $vars['q']['seq_range']['start']['backbone'];
      }
    }
    if (isset($vars['q']['seq_range']['end']['backbone'])) {
      if (isset($vars['q']['seq_range']['end']['pos'])) {
        $vars['query']['sql'][] = '    AND ((srcfeature_name = :ebackbone AND fmin <= :efmin::int) OR srcfeature_name < :ebackbone)';
        $vars['query']['args'][':ebackbone'] = $vars['q']['seq_range']['end']['backbone'];
        $vars['query']['args'][':efmin'] = (int) $vars['q']['seq_range']['end']['pos'];

        $vars['defaults']['seq_range']['end']['backbone'] = $vars['q']['seq_range']['end']['backbone'];
        $vars['defaults']['seq_range']['end']['pos'] = $vars['q']['seq_range']['end']['pos'];
      }
      else {
        $vars['query']['sql'][] = '    AND (srcfeature_name <= :ebackbone)';
        $vars['query']['args'][':ebackbone'] = $vars['q']['seq_range']['end']['backbone'];

        $vars['defaults']['seq_range']['end']['backbone'] = $vars['q']['seq_range']['end']['backbone'];
      }
    }
  }

  // --Pager.
  if (isset($vars['q']['pager_loc']['current'])) {
    if ($vars['q']['pager_loc']['current'] != $vars['q']['pager_loc']['first']) {
      $parts = explode(':', $vars['q']['pager_loc']['current']);
      $vars['query']['sql'][] = '    AND ((srcfeature_name = :srcfeature AND fmin >= :fmin) OR srcfeature_name > :srcfeature) ';
      $vars['query']['args'][':srcfeature'] = $parts[0];
      $vars['query']['args'][':fmin'] = $parts[1];
    }
  }

  // --Variant name.
  if (isset($vars['q']['variant_name']) AND !empty($vars['q']['variant_name'])) {
    $vars['query']['sql'][] = '    AND variant_name IN (:names)';
    $vars['query']['args'][':names'] = $vars['q']['variant_name'];
  }

  // --Variant type.
  if (isset($vars['q']['variant_type']) AND !empty($vars['q']['variant_type'])) {
    $vars['query']['sql'][] = '    AND variant_id IN (SELECT feature_id FROM {feature} WHERE type_id=:variant_type_id)';
    $vars['query']['args'][':variant_type_id'] = $vars['q']['variant_type'];
  }

  // -- Marker Type. (also applies to filtering by project).
  // This is much more complicated then previously thought. We cannot simply return the
  // consensus call computed across all data for positions with at least one call from
  // the specified technology because that is very misleading. Instead we need a way to
  // compute a separate consensus call per technology in addition to the master consensus
  // call. This allows us to simply choose the consensus call for a given technology
  // when asked for it.
  // One way to pull out such a consensus might be to use the new PostgreSQL 9.4
  // FILTER functionality which allows you to filter an aggregated set in place.
  // Unfortunatly this doesn't extend well to an array per technology since you
  // need to hard-code the where clause.
  /* @code
  SELECT gc.variant_id, array_agg(g.description) as alleles,
    array_agg(g.description) FILTER(WHERE stock_id=82) stock_82
  FROM genotype_call gc
  LEFT JOIN genotype g ON g.genotype_id=gc.genotype_id
  GROUP BY gc.variant_id LIMIT 5;
 variant_id |             alleles             | stock_82
------------+---------------------------------+----------
    1094657 | {CC,CC,CC,GG,GG,CC,CG,CC,CC,CC} | {CC}
    1094659 | {TT,TT,TC,TT,CC,TC,TC,TT,CC,CC} | {CC}
    1094661 | {AA,GG,AA,AG,AA,AA,AA,AA,AA,AA} | {AA}
    1094663 | {TT,AT,AT,AT,AA,TT,AA,AA,AA,AA} | {AA}
    1094665 | {AG,GG,AA,AG,AA,AG,AA,GG,AA,GG} | {AA}
  */
  //if (isset($get['marker_type']) AND !empty($get['marker_type'])) {
    //$adtl_where[] = 'markers::bigint[] <@ (SELECT array_agg(feature_id) FROM {featureprop} WHERE type_id=2534 AND value=:marker_type GROUP BY type_id)';
    //$joins = ' LEFT JOIN chado.featureprop ON ARRAY[featureprop.feature_id] <@ genotype_mview.markers::bigint[]';
    //$adtl_where[] = '(SELECT value from {featureprop} WHERE feature_id = ANY(genotype_mview.markers::bigint[]))=:marker_type';
    //$adtl_args[':marker_type'] = $get['marker_type'];
  //}

  // Finish off the query.
  $vars['query']['sql'][] = '  ORDER BY srcfeature_name ASC, fmin ASC';

  // Set the defaults for all other fields in the form.
  $fields = $vars['q'];
  unset($fields['germplasm'], $fields['seq_range']);
  foreach ($fields as $field => $value) {
    // We will validate it at the database layer using placeholders.
    $vars['defaults'][$field] = $value;
  }
 }

/**
 * Implements hook_node_view().
 * This is used to attache the Genotypes display to Marker/Variant pages.
 */
function nd_genotypes_node_view($node, $view_mode, $langcode) {
  switch ($node->type) {
    case 'chado_feature':
      if ($view_mode == 'full' AND in_array($node->feature->type_id->name, array('genetic_marker','SNP','indel'))) {

        // the tripal_natural_diversity module provides a tripal_feature_nd_genotype
        // template. if the tripal_natural_diversity content is present get rid of it as this
        // module superceeds it.
        if (array_key_exists('tripal_feature_nd_genotypes', $node->content)) {
          unset($node->content['tripal_feature_nd_genotypes']);
        }
        if (array_key_exists('tripal_feature_seqence', $node->content)) {
          unset($node->content['tripal_feature_seqence']);
        }

       // Add the two genotype specific panes: Genotypes and Sequence.
       $node->content['nd_genotypes_feature_genotypes'] = array(
          '#theme' => 'nd_genotypes_feature_genotypes',
          '#node' => $node,
          '#tripal_toc_id'    => 'genotypes',
          '#tripal_toc_title' => 'Genotypes',
        );
        // Sequence mark-up page
        $node->content['nd_genotypes_feature_sequence'] = array(
          '#theme' => 'nd_genotypes_feature_sequence',
          '#node' => $node,
          '#tripal_toc_id'    => 'sequence',
          '#tripal_toc_title' => 'Sequence',
        );
      }
    break;
  }
}

/**
 * Preprocessor: nd_genotypes_feature_sequence
 */
function nd_genotypes_preprocess_nd_genotypes_feature_sequence(&$variables) {

  // The maximum length fo sequence to show.
  $max_sequence_length = 500;

  // Is the current node a variant or a marker?
  $variant_types = unserialize(variable_get('nd_genotypes_variant_types', 'a:0:{}'));
  $marker_types = unserialize(variable_get('nd_genotypes_marker_types', 'a:0:{}'));
  $variables['type'] = NULL;
  if (in_array($variables['node']->feature->type_id->cvterm_id, $variant_types)) {
    $variant_id = $variables['node']->feature->feature_id;
    $variables['type'] = 'variant';
  }
  elseif (in_array($variables['node']->feature->type_id->cvterm_id, $marker_types)) {
    $variant_id = nd_genotypes_get_variant($variables['node']->feature->feature_id, TRUE);
    $variables['type'] = 'marker';
  }
  else {
    return;
  }

  $srcfeature = chado_query('
    SELECT
      f.feature_id,
      f.name,
      f.uniquename,
      (fmin::int-200) as substring_start,
      substring(residues from fmin::int-200 for 500) as residues,
      cf.nid,
      cvt.name as type_name
    FROM featureloc fl
      LEFT JOIN feature f ON f.feature_id=fl.srcfeature_id
      LEFT JOIN cvterm cvt ON cvt.cvterm_id=f.type_id
      LEFT JOIN chado_feature cf ON cf.feature_id=f.feature_id
    WHERE fl.feature_id=:id',
  array(':id' => $variant_id))->fetchObject();

  // Defaults.
  $variables['sequence_feature_name'] = $srcfeature->name;
  $variables['fasta_description'] = 'The following sequence is that of the ' . $srcfeature->type_name
      . ' <strong>without any variants taken into account</strong>.';
  $variables['marked_description'] = '';
  $variables['sequence'] = $srcfeature->residues;

  if ($srcfeature->residues) {
      $variables['sequence_range'] = array(
        'feature_id' => $srcfeature->feature_id,
        'feature_name' => $srcfeature->name,
        'start' => $srcfeature->substring_start,
        'end' => $srcfeature->substring_start + $max_sequence_length,
        'length' => $max_sequence_length,
        'full_sequence' => FALSE,
        'variant_id' => $variant_id,
      );
   }
   else {
      tripal_report_error(
        'nd_genotypes',
        TRIPAL_WARNING,
        'Unable to determine the sequence for the :category :name (:id)',
        array(
          ':category' => $variables['type'],
          ':name' => $variables['node']->feature->name,
          ':id' => $variables['node']->feature->feature_id
        )
      );
      return '';
  }

  if ($variables['sequence']) {
    $variables['fasta_header'] = '>' . $variables['sequence_range']['feature_name'] . ':' . $variables['sequence_range']['start'] . '-' . $variables['sequence_range']['end'] . ' (' . $variables['node']->feature->uniquename . ': ' . $variables['node']->feature->type_id->name . ')';

    // Add the marked-up sequence
    $variables['sequence_range'] = array_merge($variables['sequence_range'], array('sequence' => $variables['sequence']));
    $variables['sequence_with_variants'] = nd_genotypes_markup_sequence_with_variants(
      $variables['node']->feature,
      $variables['sequence_range'],
      $variables['type']
    );
  }
}
